\rSec1[optional]{Optional objects}

\rSec2[optional.general]{General}

\pnum
Subclause~\ref{optional} describes class template \tcode{optional} that represents
optional objects.
An \defn{optional object} is an
object that contains the storage for another object and manages the lifetime of
this contained object, if any. The contained object may be initialized after
the optional object has been initialized, and may be destroyed before the
optional object has been destroyed. The initialization state of the contained
object is tracked by the optional object.

\rSec2[optional.syn]{Header \tcode{<optional>} synopsis}

\indexheader{optional}%
\begin{codeblock}
// mostly freestanding
#include <compare>              // see \tcode{compare.syn}

namespace std {
  // \ref{optional.optional}, class template \tcode{optional}
  template <class T>
  class optional; // partially freestanding

  @\added{// \ref{optional.optional.ref}, partial specialization of \tcode{optional} for lvalue reference types }@
  @\added{template <class T> }@
  @\added{class optional<T\&>; // partially freestanding}@

  template <class T>
  constexpr bool ranges::enable_view<optional<T>> = true;
  template <class T>
  constexpr auto format_kind<optional<T>> = range_format::disabled;
  @\added{template<class T>}@
  @\added{constexpr bool ranges::enable_borrowed_range<optional<T\&>> = true;}@

  template<class T>
    concept @\defexposconcept{is-derived-from-optional}@ = requires(const T& t) {       // \expos
      []<class U>(const optional<U>&){ }(t);
    };

  // \ref{optional.nullopt}, no-value state indicator
  struct nullopt_t{@\seebelow@};
  inline constexpr nullopt_t nullopt(@\unspec@);

  // \ref{optional.bad.access}, class \tcode{bad_optional_access}
  class bad_optional_access;

  // \ref{optional.relops}, relational operators
  template<class T, class U>
    constexpr bool operator==(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator!=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator<=(const optional<T>&, const optional<U>&);
  template<class T, class U>
    constexpr bool operator>=(const optional<T>&, const optional<U>&);
  template<class T, @\libconcept{three_way_comparable_with}@<T> U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const optional<U>&);

  // \tcode{optional.nullops}, comparison with \tcode{nullopt}
  template<class T> constexpr bool operator==(const optional<T>&, nullopt_t) noexcept;
  template<class T>
    constexpr strong_ordering operator<=>(const optional<T>&, nullopt_t) noexcept;

  // \tcode{optional.comp.with.t}, comparison with \tcode{T}
  template<class T, class U> constexpr bool operator==(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator==(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator!=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator!=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator<=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator<=(const T&, const optional<U>&);
  template<class T, class U> constexpr bool operator>=(const optional<T>&, const U&);
  template<class T, class U> constexpr bool operator>=(const T&, const optional<U>&);
  template<class T, class U>
      requires (!@\exposconcept{is-derived-from-optional}@<U>) && @\libconcept{three_way_comparable_with}@<T, U>
    constexpr compare_three_way_result_t<T, U>
      operator<=>(const optional<T>&, const U&);

  // \ref{optional.specalg}, specialized algorithms
  template<class T>
    constexpr void swap(optional<T>&, optional<T>&) noexcept(@\seebelow@);

  template<class T>
    constexpr optional<decay_t<T>> make_optional(T&&);
  template<class T, class... Args>
    constexpr optional<T> make_optional(Args&&... args);
  template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

  // \ref{optional.hash}, hash support
  template<class T> struct hash;
  template<class T> struct hash<optional<T>>;
}
\end{codeblock}

\rSec2[optional.optional]{Class template \tcode{optional}}

\rSec3[optional.optional.general]{General}

\indexlibraryglobal{optional}%
\indexlibrarymember{value_type}{optional}%
\begin{codeblock}
namespace std {
  template<class T>
  class optional {
  public:
    using value_type     = T;
    using iterator       = @\impdefnc@;              // see~\ref{optional.iterators}
    using const_iterator = @\impdefnc@;              // see~\ref{optional.iterators}

    // \ref{optional.ctor}, constructors
    constexpr optional() noexcept;
    constexpr optional(nullopt_t) noexcept;
    constexpr optional(const optional&);
    constexpr optional(optional&&) noexcept(@\seebelow@);
    template<class... Args>
      constexpr explicit optional(in_place_t, Args&&...);
    template<class U, class... Args>
      constexpr explicit optional(in_place_t, initializer_list<U>, Args&&...);
    template<class U = remove_cv_t<T>>
      constexpr explicit(@\seebelow@) optional(U&&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>&);
    template<class U>
      constexpr explicit(@\seebelow@) optional(optional<U>&&);

    // \ref{optional.dtor}, destructor
    constexpr ~optional();

    // \ref{optional.assign}, assignment
    constexpr optional& operator=(nullopt_t) noexcept;
    constexpr optional& operator=(const optional&);
    constexpr optional& operator=(optional&&) noexcept(@\seebelow@);
    template<class U = remove_cv_t<T>> constexpr optional& operator=(U&&);
    template<class U> constexpr optional& operator=(const optional<U>&);
    template<class U> constexpr optional& operator=(optional<U>&&);
    template<class... Args> constexpr T& emplace(Args&&...);
    template<class U, class... Args> constexpr T& emplace(initializer_list<U>, Args&&...);

    // \ref{optional.swap}, swap
    constexpr void swap(optional&) noexcept(@\seebelow@);

    // \ref{optional.iterators}, iterator support
    constexpr iterator begin() noexcept;
    constexpr const_iterator begin() const noexcept;
    constexpr iterator end() noexcept;
    constexpr const_iterator end() const noexcept;

    // \ref{optional.observe}, observers
    constexpr const T* operator->() const noexcept;
    constexpr T* operator->() noexcept;
    constexpr const T& operator*() const & noexcept;
    constexpr T& operator*() & noexcept;
    constexpr T&& operator*() && noexcept;
    constexpr const T&& operator*() const && noexcept;
    constexpr explicit operator bool() const noexcept;
    constexpr bool has_value() const noexcept;
    constexpr const T& value() const &;                                 // freestanding-deleted
    constexpr T& value() &;                                             // freestanding-deleted
    constexpr T&& value() &&;                                           // freestanding-deleted
    constexpr const T&& value() const &&;                               // freestanding-deleted
    template<class U = remove_cv_t<T>> constexpr T value_or(U&&) const &;
    template<class U = remove_cv_t<T>> constexpr T value_or(U&&) &&;

    // \ref{optional.monadic}, monadic operations
    template<class F> constexpr auto and_then(F&& f) &;
    template<class F> constexpr auto and_then(F&& f) &&;
    template<class F> constexpr auto and_then(F&& f) const &;
    template<class F> constexpr auto and_then(F&& f) const &&;
    template<class F> constexpr auto transform(F&& f) &;
    template<class F> constexpr auto transform(F&& f) &&;
    template<class F> constexpr auto transform(F&& f) const &;
    template<class F> constexpr auto transform(F&& f) const &&;
    template<class F> constexpr optional or_else(F&& f) &&;
    template<class F> constexpr optional or_else(F&& f) const &;

    // \ref{optional.mod}, modifiers
    constexpr void reset() noexcept;

  private:
    T* val;         // \expos
  };

  template<class T>
    optional(T) -> optional<T>;
}
\end{codeblock}

\pnum
Any instance of \tcode{optional<T>} at any given time either contains a value or does not contain a value.
When an instance of \tcode{optional<T>} \defnx{contains a value}{contains a value!\idxcode{optional}},
it means that an object of type \tcode{T}, referred to as the optional object's \defnx{contained value}{contained value!\idxcode{optional}},
is nested within\iref{intro.object} the optional object.
When an object of type \tcode{optional<T>} is contextually converted to \tcode{bool},
the conversion returns \tcode{true} if the object contains a value;
otherwise the conversion returns \tcode{false}.

\pnum
When an \tcode{optional<T>} object contains a value,
member \tcode{val} points to the contained value.

\begin{removedblock}
\tcode{T} shall be a type
\tcode{T} shall be a type
other than \cv{} \tcode{in_place_t} or \cv{} \tcode{nullopt_t}
that meets the \oldconcept{Destructible} requirements (\tcode{cpp17.destructible}).

\end{removedblock}

\begin{addedblock}
\pnum
A type \tcode{X} is a \defnx{valid contained type}{valid contained type!\idxcode{optional}} for \tcode{optional} if \tcode{X} is an lvalue reference type
or a complete non-array object type, and \tcode{remove_cvref_t<X>} is a type other than \tcode{in_place_t} or \tcode{nullopt_t}.
\pnum
If a specialization of  \tcode{optional} is instantiated with a type  \tcode{T} that is not a valid contained type for  \tcode{optional}, the program is ill-formed. If  \tcode{T} is an object type,  \tcode{T} shall meet the \oldconcept{Destructible} requirements (\tcode{cpp17.destructible}).
\end{addedblock}

\rSec3[optional.ctor]{Constructors}

\pnum
The exposition-only variable template \exposid{converts-from-any-cvref}
is used by some constructors for \tcode{optional}.
\begin{codeblock}
template<class T, class W>
constexpr bool @\exposid{converts-from-any-cvref}@ =  // \expos
  disjunction_v<is_constructible<T, W&>, is_convertible<W&, T>,
                is_constructible<T, W>, is_convertible<W, T>,
                is_constructible<T, const W&>, is_convertible<const W&, T>,
                is_constructible<T, const W>, is_convertible<const W, T>>;
\end{codeblock}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional() noexcept;
constexpr optional(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\ensures
\tcode{*this} does not contain a value.

\pnum
\remarks
No contained value is initialized.
For every object type \tcode{T} these constructors are constexpr constructors\iref{dcl.constexpr}.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value
with \tcode{*rhs}.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
This constructor is defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true}.
If \tcode{is_trivially_copy_constructible_v<T>} is \tcode{true},
this constructor is trivial.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
constexpr optional(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true}.

\pnum
\effects
If \tcode{rhs} contains a value, direct-non-list-initializes the contained value
with \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}}.
\tcode{rhs.has_value()} is unchanged.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The exception specification is equivalent to
\tcode{is_nothrow_move_constructible_v<T>}.
If \tcode{is_trivially_move_constructible_v<T>} is \tcode{true},
this constructor is trivial.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class... Args> constexpr explicit optional(in_place_t, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, Args...>} is \tcode{true}.

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{std::forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor is a constexpr constructor.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U, class... Args>
  constexpr explicit optional(in_place_t, initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true}.

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{il, std::forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s constructor selected for the initialization is a constexpr constructor, this constructor is a constexpr constructor.
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U = remove_cv_t<T>> constexpr explicit(@\seebelow@) optional(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U>} is \tcode{true},
\item \tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false},
\item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false}, and
\item if \tcode{T} is \cv{} \tcode{bool},
\tcode{remove_cvref_t<U>} is not a specialization of \tcode{optional}.
\end{itemize}

\pnum
\effects
Direct-non-list-initializes the contained value with \tcode{std::forward<U>(v)}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If \tcode{T}'s selected constructor is a constexpr constructor,
this constructor is a constexpr constructor.
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<U, T>
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U> constexpr explicit(@\seebelow@) optional(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true}, and
\item if \tcode{T} is not \cv{} \tcode{bool},
\tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false}.
\end{itemize}

\pnum
\effects
If \tcode{rhs} contains a value,
direct-non-list-initializes the contained value with \tcode{*rhs}.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<const U&, T>
\end{codeblock}
\end{itemdescr}

\indexlibraryctor{optional}%
\begin{itemdecl}
template<class U> constexpr explicit(@\seebelow@) optional(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U>} is \tcode{true}, and
\item if \tcode{T} is not \cv{} \tcode{bool},
\tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false}.
\end{itemize}

\pnum
\effects
If \tcode{rhs} contains a value,
direct-non-list-initializes the contained value with \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}}.
\tcode{rhs.has_value()} is unchanged.

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
!is_convertible_v<U, T>
\end{codeblock}
\end{itemdescr}

\rSec3[optional.dtor]{Destructor}

\rSec3[optional.assign]{Assignment}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional<T>& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
If \tcode{*this} contains a value, calls \tcode{val->T::\~T()} to destroy the contained value; otherwise no effect.

\pnum
\ensures
\tcode{*this} does not contain a value.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional<T>& operator=(const optional& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
See \tcode{optional.assign.copy}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional\&)} effects}{optional.assign.copy}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
direct-non-list-initializes the contained value with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s copy constructor, no effect.
If an exception is thrown during the call to \tcode{T}'s copy assignment,
the state of its contained value is as defined by the exception safety guarantee of \tcode{T}'s copy assignment.
This operator is defined as deleted unless
\tcode{is_copy_constructible_v<T>} is \tcode{true} and
\tcode{is_copy_assignable_v<T>} is \tcode{true}.
If \tcode{is_trivially_copy_constructible_v<T> \&\&}
\tcode{is_trivially_copy_assignable_v<T> \&\&}
\tcode{is_trivially_destructible_v<T>} is \tcode{true},
this assignment operator is trivial.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
constexpr optional& operator=(optional&& rhs) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_move_assignable_v<T>} is \tcode{true}.

\pnum
\effects
See \tcode{optional.assign.move}.
The result of the expression \tcode{rhs.has_value()} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional\&\&)} effects}{optional.assign.move}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}} to the contained value &
direct-non-list-initializes the contained value with \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
The exception specification is equivalent to:
\begin{codeblock}
is_nothrow_move_assignable_v<T> && is_nothrow_move_constructible_v<T>
\end{codeblock}

\pnum
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s move constructor,
the state of \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move constructor.
If an exception is thrown during the call to \tcode{T}'s move assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by the exception safety guarantee of \tcode{T}'s move assignment.
If \tcode{is_trivially_move_constructible_v<T> \&\&}
\tcode{is_trivially_move_assignable_v<T> \&\&}
\tcode{is_trivially_destructible_v<T>} is \tcode{true},
this assignment operator is trivial.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U = remove_cv_t<T>> constexpr optional& operator=(U&& v);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false},
\item \tcode{conjunction_v<is_scalar<T>, is_same<T, decay_t<U>>>} is \tcode{false},
\item \tcode{is_constructible_v<T, U>} is \tcode{true}, and
\item \tcode{is_assignable_v<T\&, U>} is \tcode{true}.
\end{itemize}

\pnum
\effects
If \tcode{*this} contains a value, assigns \tcode{std::forward<U>(v)} to the contained value; otherwise direct-non-list-initializes the contained value with \tcode{std::forward<U>(v)}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown, the result of the expression \tcode{this->has_value()} remains unchanged. If an exception is thrown during the call to \tcode{T}'s constructor, the state of \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s constructor. If an exception is thrown during the call to \tcode{T}'s assignment, the state of \tcode{*val} and \tcode{v} is determined by the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> constexpr optional<T>& operator=(const optional<U>& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, const U\&>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, const U\&>} is \tcode{true},
\item \tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}

\pnum
\effects
See \tcode{optional.assign.copy.templ}.
\begin{lib2dtab2}{\tcode{optional::operator=(const optional<U>\&)} effects}{optional.assign.copy.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \tcode{*rhs} to the contained value &
direct-non-list-initializes the contained value with \tcode{*rhs} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\indexlibrarymember{operator=}{optional}%
\begin{itemdecl}
template<class U> constexpr optional<T>& operator=(optional<U>&& rhs);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\begin{itemize}
\item \tcode{is_constructible_v<T, U>} is \tcode{true},
\item \tcode{is_assignable_v<T\&, U>} is \tcode{true},
\item \tcode{\exposid{converts-from-any-cvref}<T, optional<U>>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, optional<U>\&\&>} is \tcode{false},
\item \tcode{is_assignable_v<T\&, const optional<U>\&>} is \tcode{false}, and
\item \tcode{is_assignable_v<T\&, const optional<U>\&\&>} is \tcode{false}.
\end{itemize}

\pnum
\effects
See \tcode{optional.assign.move.templ}.
The result of the expression \tcode{rhs.has_value()} remains unchanged.
\begin{lib2dtab2}{\tcode{optional::operator=(optional<U>\&\&)} effects}{optional.assign.move.templ}
{\tcode{*this} contains a value}
{\tcode{*this} does not contain a value}

\rowhdr{\tcode{rhs} contains a value} &
assigns \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}} to the contained value &
direct-non-list-initializes the contained value with \added{\tcode{*std::move(rhs)}}\removed{\tcode{std::move(*rhs)}} \\
\rowsep

\rowhdr{\tcode{rhs} does not contain a value} &
destroys the contained value by calling \tcode{val->T::\~T()} &
no effect \\
\end{lib2dtab2}

\pnum
\ensures
\tcode{rhs.has_value() == this->has_value()}.

\pnum
\returns
\tcode{*this}.

\pnum
\remarks
If any exception is thrown,
the result of the expression \tcode{this->has_value()} remains unchanged.
If an exception is thrown during the call to \tcode{T}'s constructor,
the state of \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s constructor.
If an exception is thrown during the call to \tcode{T}'s assignment,
the state of \tcode{*val} and \tcode{*rhs.val} is determined by
the exception safety guarantee of \tcode{T}'s assignment.
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class... Args> constexpr T& emplace(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{is_constructible_v<T, Args...>} is \tcode{true}.

\pnum
\effects
Calls \tcode{*this = nullopt}. Then direct-non-list-initializes the contained value
with \tcode{std::forward\brk{}<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
\end{itemdescr}

\indexlibrarymember{emplace}{optional}%
\begin{itemdecl}
template<class U, class... Args> constexpr T& emplace(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{is_constructible_v<T, initializer_list<U>\&, Args...>} is \tcode{true}.

\pnum
\effects
Calls \tcode{*this = nullopt}. Then direct-non-list-initializes the contained value with
\tcode{il, std::\brk{}forward<Args>(args)...}.

\pnum
\ensures
\tcode{*this} contains a value.

\pnum
\returns
A reference to the new contained value.

\pnum
\throws
Any exception thrown by the selected constructor of \tcode{T}.

\pnum
\remarks
If an exception is thrown during the call to \tcode{T}'s constructor, \tcode{*this} does not contain a value, and the previous \tcode{*val} (if any) has been destroyed.
\end{itemdescr}


\rSec3[optional.swap]{Swap}

\rSec3[optional.iterators]{Iterator support}

\rSec3[optional.observe]{Observers}

\rSec3[optional.monadic]{Monadic operations}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &;
template<class F> constexpr auto and_then(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(*\exposid{val})>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), *@\exposid{val}@);
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{and_then}{optional}
\begin{itemdecl}
template<class F> constexpr auto and_then(F&& f) &&;
template<class F> constexpr auto and_then(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{invoke_result_t<F, decltype(std::move(*\exposid{val}))>}.

\pnum
\mandates
\tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return invoke(std::forward<F>(f), std::move(*@\exposid{val}@));
} else {
  return remove_cvref_t<U>();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &;
template<class F> constexpr auto transform(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, decltype(*\exposid{val})>>}.

\pnum
\mandates
\removed{
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.}
\added{
\tcode{U} is a valid contained type for \tcode{optional}.
}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), *@\exposid{val}@));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), *\exposid{val})};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{transform}{optional}
\begin{itemdecl}
template<class F> constexpr auto transform(F&& f) &&;
template<class F> constexpr auto transform(F&& f) const &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{U} be
\tcode{remove_cv_t<invoke_result_t<F, decltype(std::move(*\exposid{val}))>>}.

\pnum
\mandates
\removed{
\tcode{U} is a non-array object type
other than \tcode{in_place_t} or \tcode{nullopt_t}.
}
\added{
\tcode{U} is a valid contained type for \tcode{optional}.
}
The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), std::move(*@\exposid{val}@)));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

\pnum
\returns
If \tcode{*this} contains a value, an \tcode{optional<U>} object
whose contained value is direct-non-list-initialized with
\tcode{invoke(std::forward<F>(f), std::move(*\exposid{val}))};
otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) const &;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}} and
\tcode{T} models \libconcept{copy_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return *this;
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{or_else}{optional}
\begin{itemdecl}
template<class F> constexpr optional or_else(F&& f) &&;
\end{itemdecl}

\begin{itemdescr}
\pnum
\constraints
\tcode{F} models \tcode{\libconcept{invocable}} and
\tcode{T} models \libconcept{move_constructible}.

\pnum
\mandates
\tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

\pnum
\effects
Equivalent to:
\begin{codeblock}
if (*this) {
  return std::move(*this);
} else {
  return std::forward<F>(f)();
}
\end{codeblock}
\end{itemdescr}

\rSec3[optional.mod]{Modifiers}

\begin{addedblock}
\rSec2[optional.optional.ref]{Partial specialization of \tcode{optional} for reference types}

\rSec3[optional.optional.ref.general]{General}
\begin{codeblock}
namespace std {
  template<class T>
  class optional<T&> {
    public:
      using value_type     = T;
      using iterator       = @\impdefnc@; // see~\ref{optional.ref.iterators}

    public:
      // \ref{optional.ref.ctor}, constructors
      constexpr optional() noexcept = default;
      constexpr optional(nullopt_t) noexcept : optional() {}
      constexpr optional(const optional& rhs) noexcept = default;

      template <class Arg>
      constexpr explicit optional(in_place_t, Arg&& arg);
      template <class U>
      constexpr explicit(@\seebelow@) optional(U&& u) noexcept(@\seebelow@);
      template <class U>
      constexpr explicit(@\seebelow@) optional(optional<U>& rhs) noexcept(@\seebelow@);
      template <class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>& rhs) noexcept(@\seebelow@);
      template <class U>
      constexpr explicit(@\seebelow@) optional(optional<U>&& rhs) noexcept(@\seebelow@);
      template <class U>
      constexpr explicit(@\seebelow@) optional(const optional<U>&& rhs) noexcept(@\seebelow@);

      constexpr ~optional() = default;

      // \ref{optional.ref.assign}, assignment
      constexpr optional& operator=(nullopt_t) noexcept;
      constexpr optional& operator=(const optional& rhs) noexcept = default;

      template <class U> constexpr T& emplace(U&& u) noexcept(@\seebelow@);

      // \ref{optional.ref.swap}, swap
      constexpr void swap(optional& rhs) noexcept;

      // \ref{optional.iterators}, iterator support
      constexpr iterator begin() const noexcept;
      constexpr iterator end() const noexcept;

      // \ref{optional.ref.observe}, observers
      constexpr T*       operator->() const noexcept;
      constexpr T&       operator*() const noexcept;
      constexpr explicit operator bool() const noexcept;
      constexpr bool     has_value() const noexcept;
      constexpr T&       value() const;                                // freestanding-deleted
      template<class U = remove_cv_t<T>> constexpr remove_cv_t<T> value_or(U&& u) const;

      // \ref{optional.ref.monadic}, monadic operations
      template <class F> constexpr auto and_then(F&& f) const;
      template <class F> constexpr optional<invoke_result_t<F, T&>> transform(F&& f) const;
      template <class F> constexpr optional or_else(F&& f) const;

      // \ref{optional.ref.mod}, modifiers
      constexpr void reset() noexcept;

    private:
      T* @\exposid{val}@ = nullptr; // \expos

      // \ref{optional.ref.expos}, exposition only helper functions
      template <class U>
      constexpr void @\exposid{convert-ref-init-val}@(U&& u); // \expos
    };
}
\end{codeblock}

\pnum
An object of \tcode{optional<T\&>} \defnx{contains a value}{contains a value!\idxcode{optional.ref}} if and only if \tcode{\exposid{val} != nullptr} is \tcode{true}.
When an \tcode{optional<T\&>} contains a value, the \defnx{contained value}{contained value!\idxcode{optional.ref}} is a reference to  \tcode{\exposid{*val}}.

\rSec3[optional.ref.ctor]{Constructors}

\begin{itemdecl}
template <class Arg>
constexpr explicit optional(in_place_t, Arg&& arg);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_constructible_v<T\&, Arg>} is \tcode{true}, and
  \item \tcode{reference_constructs_from_temporary_v<T\&, Arg>} is \tcode{false}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to: \tcode{\exposid{convert-ref-init-val}(std::forward<Arg>(arg))}.

  \pnum
  \ensures
  \tcode{*this} contains a value.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(!is_convertible_v<U, T&>)
optional(U&& u) noexcept(is_nothrow_constructible_v<T&, U>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_same_v<remove_cvref_t<U>, optional>} is \tcode{false},
  \item \tcode{is_same_v<remove_cvref_t<U>, in_place_t>} is \tcode{false}, and
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to: \tcode{\exposid{convert-ref-init-val}(std::forward<U>(u))}.

  \pnum
  \ensures
  \tcode{*this} contains a value.

  \pnum
  \remarks
  This constructor is defined as deleted if
\begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
\end{codeblock}
  is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(!is_convertible_v<U&, T&>)
optional(optional<U>& rhs) noexcept(is_nothrow_constructible_v<T&, U&>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false},
  \item \tcode{is_same_v<T\&, U>} is \tcode{false}, and
  \item \tcode{is_constructible_v<T\&, U\&>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (rhs.has_value()) @\exposid{convert-ref-init-val}@(*rhs);
  \end{codeblock}

  \pnum
  \remarks
  This constructor is defined as deleted if
\begin{codeblock}
reference_constructs_from_temporary_v<T&, U&>
\end{codeblock}
  is \tcode{true}.
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr explicit(!is_convertible_v<const U&, T&>)
optional(const optional<U>& rhs) noexcept(is_nothrow_constructible_v<T&, const U&>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false},
  \item \tcode{is_same_v<T\&, U>} is \tcode{false}, and
  \item \tcode{is_constructible_v<T\&, const U\&>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (rhs.has_value()) @\exposid{convert-ref-init-val}@(*rhs);
  \end{codeblock}


  \pnum
  \remarks
  This constructor is defined as deleted if
\begin{codeblock}
reference_constructs_from_temporary_v<T&, const U&>
\end{codeblock}
  is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(!is_convertible_v<U, T&>)
optional(optional<U>&& rhs) noexcept(is_nothrow_constructible_v<T&, U>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false},
  \item \tcode{is_same_v<T\&, U>} is \tcode{false}, and
  \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (rhs.has_value()) @\exposid{convert-ref-init-val}@(*std::move(rhs));
  \end{codeblock}

  \pnum
  \remarks
  This constructor is defined as deleted if
\begin{codeblock}
reference_constructs_from_temporary_v<T&, U>
\end{codeblock}
  is \tcode{true}.
\end{itemdescr}

\begin{itemdecl}
template <class U>
constexpr explicit(!is_convertible_v<const U, T&>)
optional(const optional<U>&& rhs) noexcept(is_nothrow_constructible_v<T&, const U>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
  \item \tcode{is_same_v<remove_cv_t<T>, optional<U>>} is \tcode{false}, and
  \item \tcode{is_same_v<T\&, U>} is \tcode{false}.
  \item \tcode{is_constructible_v<T\&, const U>} is \tcode{true},
  \end{itemize}

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (rhs.has_value()) @\exposid{convert-ref-init-val}@(*std::move(rhs));
  \end{codeblock}

  \pnum
  \remarks
  This constructor is defined as deleted if
\begin{codeblock}
reference_constructs_from_temporary_v<T&, const U>
\end{codeblock}
  is \tcode{true}.
\end{itemdescr}


\rSec3[optional.ref.assign]{Assignment}

\begin{itemdecl}
constexpr optional& operator=(nullopt_t) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Assigns \tcode{nullptr} to \exposid{val}.

  \pnum
  \ensures
  \tcode{*this} does not contain a value.

  \pnum
  \returns
  \tcode{*this}.
\end{itemdescr}


\begin{itemdecl}
template <class U>
constexpr T& emplace(U&& u) noexcept(is_nothrow_constructible_v<T&, U>);
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \begin{itemize}
    \item \tcode{is_constructible_v<T\&, U>} is \tcode{true}, and
    \item \tcode{reference_constructs_from_temporary_v<T\&, U>} is \tcode{false}.
  \end{itemize}

  \pnum
  \effects
  Equivalent to: \tcode{\exposid{convert-ref-init-val}(std::forward<U>(u))}.

  \pnum
\end{itemdescr}


\rSec3[optional.ref.swap]{Swap}

\begin{itemdecl}
constexpr void swap(optional& rhs) noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to: \tcode{swap(\exposid{val}, rhs.\exposid{val})}.
\end{itemdescr}


\rSec3[optional.ref.iterators]{Iterator support}
\begin{itemdecl}
using iterator = @\impdef@;
\end{itemdecl}

\begin{itemdescr}
\pnum
This type
models \libconcept{contiguous_iterator}\iref{iterator.concept.contiguous},
meets the \oldconcept{RandomAccessIterator} requirements\iref{random.access.iterators}, and
meets the requirements for constexpr iterators\iref{iterator.requirements.general},
with value type \tcode{remove_cv_t<T>}.
The reference type is \tcode{T\&} for \tcode{iterator}.

\pnum
All requirements on container iterators\iref{container.reqmts} apply to
\tcode{optional::iterator}.

\end{itemdescr}


\begin{itemdecl}
constexpr iterator begin() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  If \tcode{has_value()} is \tcode{true},
  an iterator referring to \tcode{*\exposid{val}}.
  Otherwise, a past-the-end iterator value.

\end{itemdescr}

\begin{itemdecl}
constexpr iterator end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\pnum
\returns
\tcode{begin() + has_value()}.
\end{itemdescr}



\rSec3[optional.ref.observe]{Observers}

\begin{itemdecl}
constexpr T* operator->() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \hardexpects
  \tcode{has_value()} is \tcode{true}.

  \pnum
  \returns
  \tcode{\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr T& operator*() const noexcept;
\end{itemdecl}

\begin{itemdescr}
   \pnum
   \hardexpects
   \tcode{has_value()} is \tcode{true}.

   \pnum
   \returns
   \tcode{*\exposid{val}}.

\end{itemdescr}

\begin{itemdecl}
constexpr explicit operator bool() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}.
\end{itemdescr}

\begin{itemdecl}
constexpr bool has_value() const noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \returns
  \tcode{\exposid{val} != nullptr}.
\end{itemdescr}

\begin{itemdecl}
constexpr T& value() const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
return has_value() ? *@\exposid{val}@ : throw bad_optional_access();
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template<class U = remove_cv_t<T>> constexpr remove_cv_t<T> value_or(U&& u) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{X} be \tcode{remove_cv_t<T>}.

  \pnum
  \mandates
    \tcode{is_constructible_v<X, T\&> \&\& is_convertible_v<U, X>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
return has_value() ? *@\exposid{val}@ : static_cast<X>(std::forward<U>(u));
  \end{codeblock}
\end{itemdescr}


\rSec3[optional.ref.monadic]{Monadic operations}

\begin{itemdecl}
template <class F>
constexpr auto and_then(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{invoke_result_t<F, T\&>}.

  \pnum
  \mandates
  \tcode{remove_cvref_t<U>} is a specialization of \tcode{optional}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value())
    return invoke(std::forward<F>(f), *@\exposid{val}@);
else
    return remove_cvref_t<U>();
  \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr optional<remove_cv_t<invoke_result_t<F, T&>>> transform(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  Let \tcode{U} be \tcode{remove_cv_t<invoke_result_t<F, T\&>>}.

  \pnum
  \mandates
  The declaration
\begin{codeblock}
U u(invoke(std::forward<F>(f), *@\exposid{val}@));
\end{codeblock}
is well-formed for some invented variable \tcode{u}.
\begin{note}
There is no requirement that \tcode{U} is movable\iref{dcl.init.general}.
\end{note}

  \pnum
  \returns
  If \tcode{*this} contains a value, an \tcode{optional<U>} object
  whose contained value is direct-non-list-initialized with
  \tcode{invoke(std::forward<F>(f), *\exposid{val})};
  otherwise, \tcode{optional<U>()}.
\end{itemdescr}

\begin{itemdecl}
template <class F>
constexpr optional or_else(F&& f) const;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \constraints
  \tcode{F} models \tcode{\libconcept{invocable}}.

  \pnum
  \mandates
  \tcode{is_same_v<remove_cvref_t<invoke_result_t<F>>, optional>} is \tcode{true}.

  \pnum
  \effects
  Equivalent to:
  \begin{codeblock}
if (has_value())
    return *@\exposid{val}@;
else
    return std::forward<F>(f)();
  \end{codeblock}
\end{itemdescr}


\rSec3[optional.ref.mod]{Modifiers}

\begin{itemdecl}
constexpr void reset() noexcept;
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Assigns \tcode{nullptr} to \exposid{val}.

  \pnum
  \ensures
  \tcode{*this} does not contain a value.
\end{itemdescr}

\rSec3[optional.ref.expos]{Exposition only helper functions}
\begin{itemdecl}
template <class U>
constexpr void @\exposid{convert-ref-init-val}@(U&& u);  // \expos
\end{itemdecl}

\begin{itemdescr}
  \pnum
  \effects
  Creates a variable \tcode{r} as if by \tcode{T\& r(std::forward<U>(u));} and then initializes \exposid{val} with \tcode{addressof(r)}.
\end{itemdescr}

\end{addedblock}

\rSec2[optional.nullopt]{No-value state indicator}
\rSec2[optional.bad.access]{Class \tcode{bad_optional_access}}
\rSec2[optional.relops]{Relational operators}
\rSec2[optional.specalg]{Specialized algorithms}
\indexlibrarymember{swap}{optional}%
\begin{itemdecl}
template<class T>
  constexpr void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y)));
\end{itemdecl}

\begin{itemdescr}
\pnum
\begin{removedblock}
\constraints
\tcode{is_move_constructible_v<T>} is \tcode{true} and
\tcode{is_swappable_v<T>} is \tcode{true}.
\end{removedblock}

\begin{addedblock}
\constraints
\tcode{is_reference_v<T> || (is_move_constructible_v<T> \&\& is_swappable_v<T>)} is \tcode{true}.
\end{addedblock}

\pnum
\effects
Calls \tcode{x.swap(y)}.
\end{itemdescr}


\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T> constexpr optional<decay_t<T>> make_optional(T&& v);
\end{itemdecl}

\begin{itemdescr}
\begin{addedblock}
\pnum
\constraints
The call to \tcode{make_optional} does not use
an explicit \grammarterm{template-argument-list} that
begins with a type \grammarterm{template-argument}.
\end{addedblock}

\pnum
\returns
\tcode{optional<decay_t<T>>(std::forward<T>(v))}.
\end{itemdescr}

\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T, class...Args>
  constexpr optional<T> make_optional(Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return optional<T>(in_place, std::forward<Args>(args)...);}
\end{itemdescr}

\indexlibraryglobal{make_optional}%
\begin{itemdecl}
template<class T, class U, class... Args>
  constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{return optional<T>(in_place, il, std::forward<Args>(args)...);}
\end{itemdescr}


\rSec2[optional.hash]{Hash support}

\begin{addedblock}
\Sec2[version.syn]{Feature-test macro}
Change the values of the following macro definition to [version.syn], header <version> synopsis, with the value selected by the editor to reflect the date of adoption of this paper:

\begin{codeblock}
  #define __cpp_lib_freestanding_optional 20XXXXL // also in <optional>
  #define __cpp_lib_optional              20XXXXL // also in <optional>
\end{codeblock}
\end{addedblock}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "new"
%%% End:
